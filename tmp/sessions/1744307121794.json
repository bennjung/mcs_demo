{
  "code": "import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract MyNFT {\n    function mint() public {\n        // NFT 민팅 로직\n    }\n}\n\n#더미데이터.ver Long\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract ElizaPluginNFT is ERC721, ERC721URIStorage, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n    \n    // NFT 생성 가격\n    uint256 public constant MINT_PRICE = 0.05 ether;\n    \n    // 최대 발행 수량\n    uint256 public constant MAX_SUPPLY = 1000;\n    \n    // NFT 메타데이터 베이스 URI\n    string private _baseTokenURI;\n\n    // 이벤트 정의\n    event NFTMinted(address indexed minter, uint256 tokenId, string tokenURI);\n    \n    constructor() ERC721(\"Eliza Plugin NFT\", \"ELIZA\") Ownable(msg.sender) {\n        _baseTokenURI = \"ipfs://QmYourBaseURI/\";\n    }\n\n    // 민팅 함수\n    function mintNFT(string memory tokenURI) public payable returns (uint256) {\n        require(msg.value >= MINT_PRICE, \"Insufficient payment\");\n        require(_tokenIds.current() < MAX_SUPPLY, \"Max supply reached\");\n\n        _tokenIds.increment();\n        uint256 newTokenId = _tokenIds.current();\n\n        _safeMint(msg.sender, newTokenId);\n        _setTokenURI(newTokenId, tokenURI);\n\n        // 초과 지불된 금액 반환\n        if (msg.value > MINT_PRICE) {\n            payable(msg.sender).transfer(msg.value - MINT_PRICE);\n        }\n\n        emit NFTMinted(msg.sender, newTokenId, tokenURI);\n        return newTokenId;\n    }\n\n    // 베이스 URI 설정 (관리자 전용)\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _baseTokenURI = baseURI;\n    }\n\n    // 컨트랙트가 받은 이더 출금 (관리자 전용)\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No balance to withdraw\");\n        payable(owner()).transfer(balance);\n    }\n\n    // 현재 발행된 토큰 수량 조회\n    function getCurrentTokenId() public view returns (uint256) {\n        return _tokenIds.current();\n    }\n\n    // OpenZeppelin 표준 오버라이드 함수들\n    function _baseURI() internal view override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage)\n        returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721URIStorage)\n        returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}",
  "auditResult": {
    "message": "Analysis Complete. Toggle down each checkboard to read details.",
    "type": "complete",
    "checks": {
      "packageCheck": {
        "status": "success",
        "title": "# Package Check",
        "details": "All package dependencies are up to date and secure."
      },
      "privateKeyCheck": {
        "status": "success",
        "title": "# Private Key Exposure Check",
        "details": "No private key exposure found in the code."
      },
      "abiCheck": {
        "status": "success",
        "title": "# ABI Check",
        "details": "Valid smart contract structure detected.",
        "code": "import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract MyNFT {\n    function mint() public {\n        // NFT 민팅 로직\n    }\n}\n\n#더미데이터.ver Long\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract ElizaPluginNFT is ERC721, ERC721URIStorage, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n    \n    // NFT 생성 가격\n    uint256 public constant MINT_PRICE = 0.05 ether;\n    \n    // 최대 발행 수량\n    uint256 public constant MAX_SUPPLY = 1000;\n    \n    // NFT 메타데이터 베이스 URI\n    string private _baseTokenURI;\n\n    // 이벤트 정의\n    event NFTMinted(address indexed minter, uint256 tokenId, string tokenURI);\n    \n    constructor() ERC721(\"Eliza Plugin NFT\", \"ELIZA\") Ownable(msg.sender) {\n        _baseTokenURI = \"ipfs://QmYourBaseURI/\";\n    }\n\n    // 민팅 함수\n    function mintNFT(string memory tokenURI) public payable returns (uint256) {\n        require(msg.value >= MINT_PRICE, \"Insufficient payment\");\n        require(_tokenIds.current() < MAX_SUPPLY, \"Max supply reached\");\n\n        _tokenIds.increment();\n        uint256 newTokenId = _tokenIds.current();\n\n        _safeMint(msg.sender, newTokenId);\n        _setTokenURI(newTokenId, tokenURI);\n\n        // 초과 지불된 금액 반환\n        if (msg.value > MINT_PRICE) {\n            payable(msg.sender).transfer(msg.value - MINT_PRICE);\n        }\n\n        emit NFTMinted(msg.sender, newTokenId, tokenURI);\n        return newTokenId;\n    }\n\n    // 베이스 URI 설정 (관리자 전용)\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _baseTokenURI = baseURI;\n    }\n\n    // 컨트랙트가 받은 이더 출금 (관리자 전용)\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No balance to withdraw\");\n        payable(owner()).transfer(balance);\n    }\n\n    // 현재 발행된 토큰 수량 조회\n    function getCurrentTokenId() public view returns (uint256) {\n        return _tokenIds.current();\n    }\n\n    // OpenZeppelin 표준 오버라이드 함수들\n    function _baseURI() internal view override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage)\n        returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721URIStorage)\n        returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}"
      }
    }
  },
  "timestamp": "2025-04-10T17:45:21.794Z"
}